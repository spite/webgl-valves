<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>webgl valves</title>	
	<style>
	*{margin:0;padding:0;box-model:border-box;}
	</style>
</head>

<script>

( function() {

	function log() {
		console.log( arguments );
	}

	function _h ( f, pre, post ) {
		return function () {
			var args = pre.apply( this, arguments ) || arguments;
			var res = f.apply( this, args );
			return post ? post( res ) : res;
		};
	}

	WebGLRenderingContext.prototype._guidBufferCount = 0;
	WebGLRenderingContext.prototype._guidProgramCount = 0;

	WebGLRenderingContext.prototype.createBuffer = _h( 
		WebGLRenderingContext.prototype.createBuffer, 
		function () {
			log( 'createBuffer', arguments )
		},
		function( buffer ) {
			buffer._guid = ++WebGLRenderingContext.prototype._guidBufferCount
			return buffer;
		}
	);

	WebGLRenderingContext.prototype.bindBuffer = _h( WebGLRenderingContext.prototype.bindBuffer, function () {
		log( 'bindBuffer', arguments[ 0 ], arguments[ 1 ]._guid )
	} );

	WebGLRenderingContext.prototype.createProgram = _h( 
		WebGLRenderingContext.prototype.createProgram, 
		function () {
			log( 'createProgram', arguments )
		},
		function( program ) {
			program._guid = ++WebGLRenderingContext.prototype._guidProgramCount
			return program;
		}
	);

	WebGLRenderingContext.prototype.useProgram = _h( WebGLRenderingContext.prototype.useProgram, function () {
		log( 'useProgram', arguments[ 0 ]._guid )
	} );

	WebGLRenderingContext.prototype.getAttribLocation = _h( WebGLRenderingContext.prototype.getAttribLocation, function () {
		log( 'getAttribLocation', arguments )
	} );

	WebGLRenderingContext.prototype.vertexAttribPointer = _h( WebGLRenderingContext.prototype.vertexAttribPointer, function () {
		log( 'vertexAttribPointer', arguments )
	} );

	WebGLRenderingContext.prototype.enableVertexAttribArray = _h( WebGLRenderingContext.prototype.enableVertexAttribArray, function () {
		log( 'enableVertexAttribArray', arguments )
	} );

	WebGLRenderingContext.prototype.drawArrays = _h( WebGLRenderingContext.prototype.drawArrays, function () {
		arguments[ 2 ] = Math.min( arguments[ 2 ], window.max );
		log( 'drawArrays', arguments )
		return arguments;
	} );

	WebGLRenderingContext.prototype.drawElements = _h( WebGLRenderingContext.prototype.drawElements, function () {
		arguments[ 1 ] = Math.min( arguments[ 1 ], window.max );
		log( 'drawElements', arguments );
		return arguments;
	} );

	// enableVertexAttribArray/vertexAttribPointer
	// useProgram
	// createBuffer/bindBuffer/bufferData

	window.max = 100000000;

})();

</script>

<script src="three.js" ></script>

<body>
</body>

<script>

var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
camera.position.z = 15;

var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio )
document.body.appendChild( renderer.domElement );

var geometries = [];
geometries.push( new THREE.IcosahedronGeometry( 1, 3 ) );
geometries.push( new THREE.BoxGeometry( 1, 1, 1, 10, 10, 10 ) );
geometries.push( new THREE.TorusKnotGeometry( 1, .3, 100, 16 ) );

var materials = [];
materials.push( new THREE.MeshNormalMaterial( { wireframe: true } ) );
materials.push( new THREE.MeshBasicMaterial( { color: 0xb70000, wireframe: true } ) );
materials.push( new THREE.MeshBasicMaterial( { color: 0x0000b7, wireframe: true } ) );

var meshes = [];
var r = 10
for( var j =0 ; j< 10; j++ ) {
	var mesh = new THREE.Mesh( geometries[ ~~ ( Math.random() * geometries.length ) ], materials[ ~~ ( Math.random() * materials.length ) ] );
	mesh.position.set( ( .5 - Math.random() ) * r, ( .5 - Math.random() ) * r, ( .5 - Math.random() ) * r )
	meshes.push( mesh );
	scene.add( mesh );
}

function onWindowResize() {
	renderer.setSize( window.innerWidth, window.innerHeight );
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
}

window.addEventListener( 'resize', onWindowResize );
onWindowResize();

function render() {
	requestAnimationFrame( render );
	meshes.forEach( function ( mesh ) {
		mesh.rotation.x += 0.01;
		mesh.rotation.y += 0.01;
	})
	console.log( '---- RENDER ---- ' )
	renderer.render( scene, camera );
}
render();

</script>

</html>